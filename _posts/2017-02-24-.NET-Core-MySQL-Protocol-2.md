---
layout: default
title: MySQL协议.NET Core实现(二)
---

在上周的[MySQL协议.NET Core实现(一)](http://www.xyting.org/2017/02/18/.NET-Core-MySql-Protocol-1.html)文章中，我们分析了MySQL协议，并使用.NET Core实现了MySQL协议的基本类型，今天，我们花一些时间实现异步Socket，以及MySQL的服务器端到客户端的握手初始化消息。

# 基础知识

## 深入理解Async/Await

我们用得很爽的C# 5 **Async/Await**语法特性，极大地简化了异步编程，但我们都很清楚**异步编程**的基础理论并没有变，其复杂度仍然在哪里。也就是说，当一些复杂的东西看起来很简单时，它通常意味着有一些有趣的事情在背后发生。我们把这些本身很复杂但看起来很简单的东西称为*语法糖*，通常情况下，我们并不需要深入理解*语法糖*是怎么被一层一层包裹起来的，但在这里，我们需要知道**Async/Await**背后到底发上了什么？

## 示例代码

为了弄清楚**Async/Await**背后到底发上了什么，我们写一个非常简单的控制台应用程序：

```csharp
namespace WhatIsAsyncAwait
{
    class Program
    {
        static void Main(string[] args)
        {
            var html = GetMySiteAsync().GetAwaiter().GetResult();
            Console.WriteLine(html);
        }

        static async Task<string> GetMySiteAsync()
        {
            var url = "http://www.xyting.org";
            Console.WriteLine("before await");
            using (var http = new HttpClient())
            {
                var html = await http.GetStringAsync(url);
                Console.WriteLine("after await");
                return html;
            }
        }
    }
}
```

## 编译器生成的代码

上面的代码，C#编译器在编译的时候，会进行重写，我们使用反编译软件(ILSpy, Reflector)可以查看到C#编译器生成的代码：

```csharp
internal class Program
{
    // Methods
    [AsyncStateMachine(typeof(<GetMySiteAsync>d__1)), DebuggerStepThrough]
    private static Task<string> GetMySiteAsync()
    {
        <GetMySiteAsync>d__1 stateMachine = new <GetMySiteAsync>d__1 {
            <>t__builder = AsyncTaskMethodBuilder<string>.Create(),
            <>1__state = -1
        };
        stateMachine.<>t__builder.Start<<GetMySiteAsync>d__1>(ref stateMachine);
        return stateMachine.<>t__builder.Task;
    }

    private static void Main(string[] args)
    {
        Console.WriteLine(GetMySiteAsync().GetAwaiter().GetResult());
    }

    // Nested Types
    [CompilerGenerated]
    private sealed class <GetMySiteAsync>d__1 : IAsyncStateMachine
    {
        // Fields
        public int <>1__state;
        private string <>s__4;
        public AsyncTaskMethodBuilder<string> <>t__builder;
        private TaskAwaiter<string> <>u__1;
        private string <html>5__3;
        private HttpClient <http>5__2;
        private string <url>5__1;

        // Methods
        private void MoveNext()
        {
            string str;
            int num = this.<>1__state;
            try
            {
                if (num != 0)
                {
                    this.<url>5__1 = "http://www.xyting.org";
                    Console.WriteLine("before await");
                    this.<http>5__2 = new HttpClient();
                }
                try
                {
                    TaskAwaiter<string> awaiter;
                    if (num != 0)
                    {
                        awaiter = this.<http>5__2.GetStringAsync(this.<url>5__1).GetAwaiter();
                        if (!awaiter.IsCompleted)
                        {
                            this.<>1__state = num = 0;
                            this.<>u__1 = awaiter;
                            Program.<GetMySiteAsync>d__1 stateMachine = this;
                            this.<>t__builder.AwaitUnsafeOnCompleted<TaskAwaiter<string>, Program.<GetMySiteAsync>d__1>(ref awaiter, ref stateMachine);
                            return;
                        }
                    }
                    else
                    {
                        awaiter = this.<>u__1;
                        this.<>u__1 = new TaskAwaiter<string>();
                        this.<>1__state = num = -1;
                    }
                    string result = awaiter.GetResult();
                    awaiter = new TaskAwaiter<string>();
                    this.<>s__4 = result;
                    this.<html>5__3 = this.<>s__4;
                    this.<>s__4 = null;
                    Console.WriteLine("after await");
                    str = this.<html>5__3;
                }
                finally
                {
                    if ((num < 0) && (this.<http>5__2 != null))
                    {
                        this.<http>5__2.Dispose();
                    }
                }
            }
            catch (Exception exception)
            {
                this.<>1__state = -2;
                this.<>t__builder.SetException(exception);
                return;
            }
            this.<>1__state = -2;
            this.<>t__builder.SetResult(str);
        }

        [DebuggerHidden]
        private void SetStateMachine(IAsyncStateMachine stateMachine)
        {
        }
    }
}
```

被C#重写之后的代码，不仅命名有点奇葩，而且内容貌似也看不懂了。不过，C# 7都差不多正式出来了，也就是说C# 5 **Async/Await**我们已经使用了好几年，这几年在写代码的过程中，我们发现**async**方法的返回类型是被限制成几种特性类型的，那么我们就从这几种类型着手。

## 三种返回类型， 三种Builder

我们知道，异步方法仅限于三个不同的返回类型︰

- void
- Task
- Task<T>

而C#编译器在编译这些异步方法时，还需要三个Builder：

- AsyncVoidMethodBuilder
- AsyncTaskMethodBuilder
- AsyncTaskMethodBuilder<T>

撇开这三个Builder的内部实现，从接口角度讲，他们很像：

```csharp
public struct AsyncVoidMethodBuilder
{
    public static AsyncVoidMethodBuilder Create()
    {
        return new AsyncVoidMethodBuilder();
    }

    public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)
        where TAwaiter : INotifyCompletion
        where TStateMachine : IAsyncStateMachine
    {

    }

    public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)
        where TAwaiter : ICriticalNotifyCompletion 
        where TStateMachine : IAsyncStateMachine
    {

    }

    public void SetStateMachine(IAsyncStateMachine stateMachine) { }

    public void Start<TStateMachine>(ref TStateMachine stateMachine)
        where TStateMachine : IAsyncStateMachine
    {

    }

    public void SetException(Exception e) { }
    public void SetResult() { }
}

public struct AsyncTaskMethodBuilder
{
    public static AsyncTaskMethodBuilder Create()
    {
        return new AsyncTaskMethodBuilder();
    }

    public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)
        where TAwaiter : INotifyCompletion
        where TStateMachine : IAsyncStateMachine
    {

    }

    public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)
        where TAwaiter : ICriticalNotifyCompletion
        where TStateMachine : IAsyncStateMachine
    {

    }

    public void SetStateMachine(IAsyncStateMachine stateMachine) { }

    public void Start<TStateMachine>(ref TStateMachine stateMachine)
        where TStateMachine : IAsyncStateMachine
    {

    }

    public void SetException(Exception e) { }
    public void SetResult() { }
    public Task Task { get; }
}

public struct AsyncTaskMethodBuilder<T>
{
    public static AsyncTaskMethodBuilder<T> Create()
    {
        return new AsyncTaskMethodBuilder<T>();
    }

    public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)
        where TAwaiter : INotifyCompletion
        where TStateMachine : IAsyncStateMachine
    {

    }

    public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)
        where TAwaiter : ICriticalNotifyCompletion
        where TStateMachine : IAsyncStateMachine
    {

    }

    public void SetStateMachine(IAsyncStateMachine stateMachine) { }

    public void Start<TStateMachine>(ref TStateMachine stateMachine) 
        where TStateMachine : IAsyncStateMachine
    {

    }

    public void SetException(Exception e) { }
    public void SetResult(T result) { }
    public Task<T> Task { get; }
}
```

## Awaitables and Awaiters